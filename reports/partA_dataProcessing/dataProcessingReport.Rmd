---
params:
  subtitle: ""
  title: ""
  authors: ""
title: '`r params$title`'
subtitle: '`r params$subtitle`'
author: '`r params$authors`'
date: 'Last run at: `r getRunDateTime()`'
output:
  bookdown::html_document2:
    fig_caption: yes
    code_folding: hide
    number_sections: yes
    toc: yes
    toc_depth: 2
    toc_float: TRUE
  bookdown::pdf_document2:
    fig_caption: yes
    number_sections: yes
bibliography: '`r paste0(here::here(), "/bibliography.bib")`'
---

```{r knitrSetup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE) # by default turn off code echo
```


```{r codeSetup, include=FALSE}
# Set start time ----
startTime <- proc.time()
# Local parameters ----
b2Kb <- 1024 #http://whatsabyte.com/P1/byteconverter.htm
b2Mb <- 1048576
plotLoc <- paste0(repoParams$repoLoc, "/docs/plots/") # where to put the plots

# Packages used in the report ----
rmdLibs <- c("ggplot2", # plots
          "kableExtra" # fancy tables
          )
GREENGridEECA::loadLibraries(rmdLibs)
# Local functions ----
```

\newpage

# About

## Citation

```{r citation, child=repoParams$citation}
```

## Report circulation:

 * Public â€“ this report is intended for publication following EECA approval.
 
## License

```{r ccby license, child=repoParams$licenseCCBY}
```
 
## History

```{r history, child=repoParams$history}
```
 * this [report's edit history](https://github.com/CfSOtago/GREENGridEECA/commits/master/reports/partA_dataProcessing)
 
## Support

```{r generic support, child=repoParams$support}
```
 
\newpage

# Introduction

This report uses the GREEN Grid project [@stephenson_smart_2017] research data to...

> XX tbc

# Data

```{r generic sample, child=repoParams$data}
```
 
# Multi-year data availability

Whilst the GREEN Grid project collected data from `r min(lubridate::date(hhPowerDataDT$r_dateTimeHalfHour))` to `r max(lubridate::date(hhPowerDataDT$r_dateTimeHalfHour))`, we do not have complete multi-year coverage of the `r uniqueN(hhPowerDataDT$linkID)` dwellings for whom data exists.

As Figure \@ref(fig:reportMyTile) shows data is available for most of the `r uniqueN(hhDataDT[Location == "Taranaki"])` dwellings in the Taranaki region from mid 2014 and for most of the `r uniqueN(hhDataDT[Location == "Hawkes Bay"])` dwellings in Hawkes Bay from early 2015. In most cases the 'right' number of observations were received per half hour (30) when the dwellings were sending data. However not all dwellings sent data continuously with substantial attrition by 2017 (Figure \@ref(fig:reportMyCol).

```{r reportMyTile, fig.cap="Mean number of observations per circuit per half hour", fig.height=8}
myCaption <- "Source: GREEN Grid dwelling power demand data"

plotDT <- hhPowerDataDT[, .(meanNObs = mean(nObs)), 
                    keyby = .(linkID, 
                              date = lubridate::date(hhPowerDataDT$r_dateTimeHalfHour))]
setkey(plotDT, linkID)
setkey(hhDataDT, linkID)
plotDT <- hhDataDT[plotDT]
plotDT[, Location := ifelse(is.na(Location), "Test installs", Location)] # gs data but no survey etc

ggplot2::ggplot(plotDT[!(Location %like% "Test")], aes(x = date, y = linkID, fill = meanNObs)) +
  geom_tile() +
  facet_grid(Location ~ .,scales = "free_y") +
  scale_fill_continuous(low = "red", high = "green", name = "Mean n observations per circuit\nper half hour") +
  labs(x = "Date", y = "ID", caption = paste0(myCaption,"\n 2 test installs removed (rf_01, rf_02)")) +
   theme(legend.position="bottom")
```


```{r reportMyCol, fig.cap="Number of dwellings sending data per day", fig.height=8}

plotDT <- plotDT[, .(nDwellings = uniqueN(linkID)), 
                    keyby = .(Location, date)]


ggplot2::ggplot(plotDT[!(Location %like% "Test")], aes(x = date, y = nDwellings, fill = Location)) +
  geom_col(position = "stack") +
  labs(x = "Date", y = "N dwellings", 
       caption = paste0(myCaption,
                        "\n 2 test installs removed (rf_01, rf_02)")) +
   theme(legend.position="bottom")
```

For clarity, Figure \@ref(fig:reportSeasonal) shows the mean daily number of dwellings present in the data in each year and season for each region. Whilst it is clear that 2015 provides the highest level of reporting dwellings, it also shows that it would be at least possible to calculate seasonal summaries for several years.

```{r reportSeasonal, fig.cap="Active dwellings by season"}
dt <- GREENGridEECA::addNZSeason(plotDT, date)
dt <- dt[, year := lubridate::year(date)]
t <- dt[, .(meanDwellings = mean(nDwellings)), keyby = .(year, season, Location)]
ggplot2::ggplot(t, aes(x = season, y = meanDwellings, fill = Location)) +
  geom_col() +
  labs(x = "Season", y = "Mean number of dwellings per season",
       caption = paste0(myCaption, "\nAll dwellings")) +
  facet_grid(. ~ year) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
```

However, it should be noted that:

 * not all dwellings contained the appliance circuits of analyitic interest;
 * one dwelling (rf_46) has ambiguous circuit labels and so [should be ignored](https://github.com/CfSOtago/GREENGridData/issues/1);
 * a number of dwellings have a very high proportion of -ve power values for some circuits mostl likely due to PV installation (e.g. [rf_14,rf_25,rf_26,rf_43](https://cfsotago.github.io/GREENGridData/reportTotalPower_circuitsToSum_v1.1.html#6_implications)) and so should be ignored if total dwelling load is required;
 * similarly [some dwellings]((https://cfsotago.github.io/GREENGridData/reportTotalPower_circuitsToSum_v1.1.html#6_implications)) have a small number of -ve power values on non-PV circuits at some times, possibly due to brief incorrect fitting of the monitors.

As a result the _effective_ number of dwellings available for any given analysis will always be _lower_ than the numbers reported above and should be evaluated on a case by case basis.

# Imputation of 'total load' per minute per dwelling

Whilst in theory the calculation of total load in any given minute should be a matter of merely summing all monitored circuits, in practice the task is not quite this simple. There are a number of reasons for this:

 * for some dwellings the hot water circuit is seperately metered and thus monitored but for others it is part of the overall 'incomer/mains' demand;
 * photovoltaic panels were installed in several dwellings which produce negative power values and so would reduce apparent demand if naively aggregated;
 * several dwellings report either systematic or intemittent negative values yet do not have PV installations.
 
Our previously work has shown that [with appropriate care](https://cfsotago.github.io/GREENGridData/reportTotalPower_circuitsToSum_v1.1.html) it is possible to derive best effort estimates of total dwelling power load by summing a small number of particular circuits for each dwelling [@GREENGridTotalLoad]. However the issues described above mean that users should:

 * exclude dwellings with (link) IDs: `rf_14`,`rf_25`,`rf_26` and `rf_43` due to substantial unexplained negative values;
 * exclude other -ve values on a per-value basis. _We recommend setting such values to NA (__not 0__)_;
 * include dwellings known to have PV _only if_ analysis of demand during non-daylight hours is being undertaken or if net demand is of interest.

Seperately, for reasons explained [elsewhere](https://cfsotago.github.io/GREENGridData/gridSpy1mOutliersReport_v1.0.html#45_the_mysterious_case_of_rf_46) we also recommend removing `rf_46` from the data prior to analysis.

In all cases we recommend that users check the data carefully before analysis and document any filtering they apply.

We have therefore created a new dataset for each dwelling which comprises the estimated total load per minute for each dwelling for the entire time frame for which we have data (ref Figure \@ref(fig:reportMyCol)). For ease of use this data is available as:

 * an additional set of observations added to the end of each clean data file with circuit label set to `imputedTotalDemand_circuitsToSum_v1.1` indicating that the [aggregation code](https://github.com/CfSOtago/GREENGridData/blob/master/dataProcessing/gridSpy/imputeTotalPower.R) used the [circuitsToSum definition v1.1](https://github.com/CfSOtago/GREENGridData/blob/master/data/circuitsToSum_v1.1.csv);
 * a single file containing _only_ the estimated total load per minute per dwelling.

Note that we have _not_ applied the exclusion rules described above. In order to ensure all data is available if required, these rules should only be applied just prior to analysis. The files are listed in Table \@ref(tab:listLoadFiles). Whilst we can make these data files available, potential users should note that they are _larger_ than the original data files. The single file containing _only_ the estimated total load per minute per dwelling is especially large. 

```{r listLoadFiles}
kableExtra::kable(impfilesDT[all.files %like% "v1.1", .(file = all.files, "Mb (gzipped)" = fSizeMb)], caption = "Size of clean data files with estimated load", digits = 2) %>%
  kable_styling()

```

Table \@ref(tab:allLoadDesc) shows basic statistics for the estimated 1 minute level load for each dwelling and illustrates some of the issues described above.

```{r allLoadDesc}
t <- impDataDT[, .(nObs = GREENGridData::tidyNum(.N),
                   meanW = mean(powerW),
                   minW = min(powerW),
                   maxW = max(powerW),
                   sdW = sd(powerW)), keyby = (linkID)]

setkey(t, linkID)
t2 <- hhDataDT[, .(linkID, `PV Inverter`, Location)][t]
t2[, Location := ifelse(is.na(Location), "Test installs", Location)] # gs data but no survey etc

kableExtra::kable(t2, caption = "Basic statistics for the estimated 1 minute level load (W) for each dwelling", digits = 2) %>%
  kable_styling()

```


# Development of a half-hourly power demand dataset

In response to EECA's request we have used the per-dwelling files listed in Table \@ref(tab:listLoadFiles) to produce an aggregated half-hourly power demand dataset __for each dwelling__.

These files contain:

 * `r_dateTimeHalfHour` (in UTC) in half hours;
 * number of observations, mean, min, max and standard deviation of power (W) for each half hour;
 * `circuit` label with total load labelled as `imputedTotalDemand_circuitsToSum_v1.1`;
 * dwelling `linkID` (for linkage to survey data).

Table \@ref(tab:headhhFile) shows the first few rows of one of these files.

```{r headhhFile}
kableExtra::kable(head(origHHDataDT), caption = "Half hourly data format with example data", digits = 2) %>%
  kable_styling()

```

The resulting files are listed in Table \@ref(tab:listhhFiles).

```{r listhhFiles}
kableExtra::kable(hhfilesDT[, .(file = all.files, "Mb (gzipped)" = fSizeMb)], caption = "Size of clean half hourly data files", digits = 2) %>%
  kable_styling()

```

Further, these per-dwelling files have been used to attempt to create single data files containing all observations for the circuits or (partial) circuit labels set out in the following sections. Table \@ref(tab:getCircuitLabels) in Section \@ref(circuitLabels) of the Data Annex shows the unique circuit labels available as a guide to what can be meaningfully extracted.

```{r fixCircuitLabels}
hhPowerDataDT[, c("circuitLabel", "circuitID") := tstrsplit(circuit, "$", fixed = TRUE)]
```



## Lighting

```{r setFilter_Lighting}
filter <- "Lighting"
```

In this section we extract every record where:

 * the string "`r filter`" is found in `circuit`
 
Table \@ref(tab:extractHalfHourLighting) and Figure \@ref(fig:extractHalfHourLighting) show summary statistics of the half-hourly mean values for all observations extracted by circuit label. Note that the process may have matched a number of circuits and in some cases circuits may contain other appliances. Analysis should therefore proceed with caution.

```{r extractHalfHourLighting, fig.cap = "Lighting data summary"}

makeTable <- function(dt){
  t <- dt[, .(nObs = .N,
              nDwellings = uniqueN(linkID),
              meanW = mean(meanPowerW, na.rm = TRUE),
              minW = min(meanPowerW, na.rm = TRUE),
              maxW = max(meanPowerW, na.rm = TRUE),
              sdW = sd(meanPowerW, na.rm = TRUE)
              ),
                  keyby = .(circuitLabel)]
  return(t)
}

dt <- hhPowerDataDT[circuitLabel %like% filter]

t <- makeTable(dt)

kableExtra::kable(t, digits = 3, 
                  caption = paste0("Summary statistics for extract")) %>%
  kable_styling()

of <- paste0(repoParams$GreenGridData, "/gridSpy/halfHour/extracts/halfHourLighting.csv")
data.table::fwrite(dt, of)
GREENGridEECA::gzipIt(of)

makeTilePlot <- function(dt){
  plotDT <- dt[, .(meanW = mean(meanPowerW),
                   nObs = .N), keyby = .(r_dateTimeHalfHour, circuitLabel)]
  p <- ggplot2::ggplot(plotDT, aes(x = r_dateTimeHalfHour, 
                                   y = circuitLabel, 
                                   fill = meanW,
                                   alpha = nObs)) +
    geom_tile() +
    scale_fill_continuous(low = "green", high = "red") +
    labs(x = "Half hour", y = "Circuit label", caption = "Fill colour (meanW): Mean of half-hourly mean power\nAlpha (nObs): Number of half hourly observations contributing")
  return(p)
}
makeTilePlot(dt)
```

We therefore have _Lighting_ data for `r sum(t$nDwellings)` dwellings.

## Hot water

```{r setFilter_HotWater}
# more complex
filter1 <- "Hot water"
filter2 <- "Hot Water"
```

In this section we extract every record where:

 * the string "`r filter1`" is found in `circuit`
 * the string "`r filter2`" is found in `circuit`
 
Table \@ref(tab:extractHalfHourHotWater) and Figure \@ref(fig:extractHalfHourHotWater) show the mean power (mean of the half-hourly mean values)
for all observations extracted by circuit label. Note that in some cases circuits may contain other appliances. Analysis should therefore proceed with caution.

```{r extractHalfHourHotWater, fig.cap = "Hot water data summary"}

dt <- hhPowerDataDT[circuitLabel %like% filter1 |
                                circuitLabel %like% filter2]

t <- makeTable(dt)

kableExtra::kable(t, digits = 3, 
                  caption = paste0("Summary statistics for extract")) %>%
  kable_styling()

of <- paste0(repoParams$GreenGridData, "/gridSpy/halfHour/extracts/halfHourHotWater.csv")
data.table::fwrite(dt, of)
GREENGridEECA::gzipIt(of)
makeTilePlot(dt)
```

We therefore have _Hot Water_ data for `r sum(t$nDwellings)` dwellings.


## Heat pumps
 

```{r setFilter_HeatPump}
# more complex
filter1 <- "Heat Pump"
```

In this section we extract every record where:

 * the string "`r filter1`" is found in `circuit`
 
Table \@ref(tab:extractHalfHourHeatPump) and Figure \@ref(fig:extractHalfHourHeatPump) show the mean power (mean of the half-hourly mean values)
for all observations extracted by circuit label. Note that in some cases circuits may contain other appliances. Analysis should therefore proceed with caution.

```{r extractHalfHourHeatPump, fig.cap = "Heat Pump data summary"}

dt <- hhPowerDataDT[circuitLabel %like% filter1]

t <- makeTable(dt)

kableExtra::kable(t, digits = 3, 
                  caption = paste0("Summary statistics for extract")) %>%
  kable_styling()

of <- paste0(repoParams$GreenGridData, "/gridSpy/halfHour/extracts/halfHourHeatPump.csv")
data.table::fwrite(dt, of)
GREENGridEECA::gzipIt(of)
makeTilePlot(dt)
```

We therefore have _Heat Pump_ data for `r sum(t$nDwellings)` dwellings.

## Kitchen

Noting that this may include other areas of the dwelling...

```{r setFilter_Kitchen}
# more complex
filter1 <- "Kitchen"
```

In this section we extract every record where:

 * the string "`r filter1`" is found in `circuit`
 
Table \@ref(tab:extractHalfHourKitchen) and Figure \@ref(fig:extractHalfHourKitchen) show the mean power (mean of the half-hourly mean values)
for all observations extracted by circuit label. Note that in some cases circuits may contain other appliances. Analysis should therefore proceed with caution.

```{r extractHalfHourKitchen, fig.cap = "Kitchen data summary"}

dt <- hhPowerDataDT[circuitLabel %like% filter1]

t <- makeTable(dt)

kableExtra::kable(t, digits = 3, 
                  caption = paste0("Summary statistics for extract")) %>%
  kable_styling()

of <- paste0(repoParams$GreenGridData, "/gridSpy/halfHour/extracts/halfHourKitchen.csv")
data.table::fwrite(dt, of)
GREENGridEECA::gzipIt(of)
makeTilePlot(dt)
```

We therefore have _Kitchen_ data for `r sum(t$nDwellings)` dwellings.

## Non-heat pump â€˜Heatâ€™ 

Noting that this circuit label may include other appliances...


```{r setFilter_Heat}
# more complex
filter1 <- "Heat"
```

In this section we extract every record where:

 * the string "`r filter1`" is found in `circuit` but excluding 'Heat Pump'
 
Table \@ref(tab:extractHalfHourHeat) and Figure \@ref(fig:extractHalfHourHeat) show the mean power (mean of the half-hourly mean values)
for all observations extracted by circuit label. Note that in some cases circuits may contain other appliances. Analysis should therefore proceed with caution.

```{r extractHalfHourHeat, fig.cap = "Heat data summary"}

dt <- hhPowerDataDT[circuitLabel %like% filter1 &
                      !circuitLabel %like% "Heat Pump"]

t <- makeTable(dt)

kableExtra::kable(t, digits = 3, 
                  caption = paste0("Summary statistics for extract")) %>%
  kable_styling()

of <- paste0(repoParams$GreenGridData, "/gridSpy/halfHour/extracts/halfHourNonHP_Heat.csv")
data.table::fwrite(dt, of)
GREENGridEECA::gzipIt(of)
makeTilePlot(dt)
```

We therefore have non Heat Pump _Heat_ data for `r sum(t$nDwellings)` dwellings.

## Refrigerator/Fridge

Noting that this circuit label may include other appliances...

```{r setFilter_Fridge}
# more complex
filter1 <- "Fridge"
```

In this section we extract every record where:

 * the string "`r filter1`" is found in `circuit`
 
Table \@ref(tab:extractHalfHourFridge) and Figure \@ref(fig:extractHalfHourFridge) show the mean power (mean of the half-hourly mean values)
for all observations extracted by circuit label. Note that in some cases circuits may contain other appliances. Analysis should therefore proceed with caution.

```{r extractHalfHourFridge, fig.cap = "Fridge data summary"}

dt <- hhPowerDataDT[circuitLabel %like% filter1]

t <- makeTable(dt)

kableExtra::kable(t, digits = 3, 
                  caption = paste0("Summary statistics for extract")) %>%
  kable_styling()

of <- paste0(repoParams$GreenGridData, "/gridSpy/halfHour/extracts/halfHourFridge.csv")
data.table::fwrite(dt, of)
GREENGridEECA::gzipIt(of)
makeTilePlot(dt)
```

We therefore have _Fridge_ data for `r sum(t$nDwellings)` dwellings.

## Freezer

Noting that this circuit label may include other appliances...

```{r setFilter_Freezer}
# more complex
filter1 <- "Freezer"
```

In this section we extract every record where:

 * the string "`r filter1`" is found in `circuit`
 
Table \@ref(tab:extractHalfHourFreezer) and Figure \@ref(fig:extractHalfHourFreezer) show the mean power (mean of the half-hourly mean values)
for all observations extracted by circuit label. Note that in some cases circuits may contain other appliances. Analysis should therefore proceed with caution.

```{r extractHalfHourFreezer, fig.cap = "Freezer data summary"}

dt <- hhPowerDataDT[circuitLabel %like% filter1]

t <- makeTable(dt)

kableExtra::kable(t, digits = 3, 
                  caption = paste0("Summary statistics for extract")) %>%
  kable_styling()

of <- paste0(repoParams$GreenGridData, "/gridSpy/halfHour/extracts/halfHourFreezer.csv")
data.table::fwrite(dt, of)
GREENGridEECA::gzipIt(of)
makeTilePlot(dt)
```

We therefore have _Freezer_ data for `r sum(t$nDwellings)` dwellings.

## Total load

In this section we extract every record where:

 * the string "`imputedTotalDemand`" is found in `circuit`
 
Table \@ref(tab:extractHalfHourtotalLoad) and Figure \@ref(fig:extractHalfHourtotalLoad) show the mean power (mean of the half-hourly mean values) for all observations extracted by circuit label.

```{r extractHalfHourtotalLoad, fig.cap = "Total load data summary"}

dt <- hhPowerDataDT[circuitLabel %like% "imputedTotalDemand"]

t <- makeTable(dt)

kableExtra::kable(t, digits = 3, 
                  caption = paste0("Summary statistics for extract")) %>%
  kable_styling()

of <- paste0(repoParams$GreenGridData, "/gridSpy/halfHour/extracts/halfHourImputedTotalDemand.csv")
data.table::fwrite(dt, of)
GREENGridEECA::gzipIt(of)
makeTilePlot(dt)
```

We therefore have _imputedTotalDemand_ data for `r sum(t$nDwellings)` dwellings.


# Summary

> XX tbc

```{r runToEnd}

```

# Data Annex

## Half hourly total load summary 
Descriptive statistics for aggregate half hourly power data for all dwellings and all circuits:

```{r skimData}
skimr::skim(hhPowerDataDT)
```

## Per dwelling summaries of half-hourly power data

The following tables show descriptive statistics for the meanPowerW values for each circuit by dwelling.

```{r powerCube, results = "asis", warning=FALSE}
ids <- unique(hhPowerDataDT$linkID)

for(hh in ids){
  # prints a lot of tables

  message("#-> Dwelling: ", hh)

    t <- data.table::cube(hhPowerDataDT[linkID == hh], j = c(list(meanPowerW = mean(meanPowerW, na.rm = TRUE),
                                                              minPowerW = min(meanPowerW, na.rm = TRUE),
                                                              maxPowerW = max(meanPowerW, na.rm = TRUE),
                                                              nObs = .N)), by = c("circuit"))
    # NA in circuit column of ersults table = All
    t[, circuit := ifelse(is.na(circuit), "All", circuit)]
    print(kableExtra::kable(t, caption = paste0(hh, ": Mean of half-hourly mean power (W) by circuit type")) %>% 
      kable_styling())
}

```

## Circuit labels (all){#circuitLabels}

```{r getCircuitLabels}

t <- hhPowerDataDT[, .(nObs = .N,
                      nDwellings = uniqueN(linkID),
                      meanW = mean(meanPowerW, na.rm = TRUE)),
                  keyby = .(circuitLabel)]

kableExtra::kable(t, 
                  caption = "Summary statistics by circuit label")

# save as a data file for ease of use
of <- paste0(repoParams$repoLoc, "/data/circuitLabelsComplete.csv")
data.table::fwrite(t, file = of)

```

# Runtime


```{r check runtime, include=FALSE}
t <- proc.time() - startTime
elapsed <- t[[3]]
```

Analysis completed in `r round(elapsed,2)` seconds ( `r round(elapsed/60,2)` minutes) using [knitr](https://cran.r-project.org/package=knitr) in [RStudio](http://www.rstudio.com) with `r R.version.string` running on `r R.version$platform`.

# R environment

## R packages used

 * base R [@baseR]
 * bookdown [@bookdown]
 * data.table [@data.table]
 * ggplot2 [@ggplot2]
 * kableExtra [@kableExtra]
 * knitr [@knitr]
 * lubridate [@lubridate]
 * rmarkdown [@rmarkdown]

## Session info

```{r sessionInfo, echo=FALSE}
sessionInfo()
```

# References
