---
params:
  subtitle: ""
  title: ""
  authors: ""
title: '`r params$title`'
subtitle: '`r params$subtitle`'
author: '`r params$authors`'
date: 'Last run at: `r getRunDateTime()`'
output:
  bookdown::html_document2:
    fig_caption: yes
    code_folding: hide
    number_sections: yes
    toc: yes
    toc_depth: 2
    toc_float: TRUE
  bookdown::pdf_document2:
    fig_caption: yes
    number_sections: yes
bibliography: '`r paste0(here::here(), "/bibliography.bib")`'
---

```{r knitrSetup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE) # by default turn off code echo
```


```{r codeSetup, include=FALSE}
# Set start time ----
startTime <- proc.time()
# Local parameters ----
b2Kb <- 1024 #http://whatsabyte.com/P1/byteconverter.htm
b2Mb <- 1048576
plotLoc <- paste0(repoParams$repoLoc, "/docs/plots/") # where to put the plots (if any)

# Packages used in the report ----
libs <- c("ggplot2", # plots
          "kableExtra", # fancy tables
          "hms", # times
          "skimr" # for skim
          )
          
# Local functions ----

library(kableExtra)
library(dplyr)
library(ggplot2)
library(tidyr)
```

\newpage

# About

## Citation

```{r citation, child=repoParams$citation}
```

## Report circulation:

 * Public â€“ this report is intended for publication.
 
## License

```{r ccby license, child=repoParams$licenseCCBY}
```
 
## History

```{r history, child=repoParams$history}
```
 * this [report's edit history](https://github.com/CfSOtago/GREENGridEECA/commits/master/reports/partB_dataAnalysis)
 
## Support

```{r generic support, child=repoParams$support}
```
 
\newpage

# Introduction

This report uses the GREEN Grid project [@stephenson_smart_2017] research data to...

# Data

```{r generic sample, child=repoParams$data}
```

```{r Part B: data processing}
# put all this here before you report on it
# this code _could_ go in the makeFile if you want...

#New DT
powerDT <- copy(origPowerDT) # need to copy as data.table works by reference https://www.rdocumentation.org/packages/data.table/versions/1.12.2/topics/copy

#DT modifications

#Excluding households based on report
exclude <- c("rf_14", "rf_25", "rf_26", "rf_43", "rf_46")
powerDT <- powerDT[!(linkID %in% exclude)]

# setting negative values to NA
powerDT <- powerDT[, meanPowerW := ifelse(meanPowerW <0, NA, meanPowerW)]
powerDT <- powerDT[, sdPowerW := ifelse(sdPowerW <0, NA, sdPowerW)]
powerDT <- powerDT[, minPowerW := ifelse(minPowerW <0, NA, minPowerW)]
powerDT <- powerDT[, maxPowerW := ifelse(maxPowerW <0, NA, maxPowerW)]


# set to NZ time from UTC
powerDT <- powerDT[, r_dateTime_nz := lubridate::as_datetime(r_dateTimeHalfHour, 
                                               tz = "Pacific/Auckland")] # this will be UTC unless you set this

#Define Winter/else
powerDT <- powerDT[, date := lubridate::date(r_dateTime_nz)]
powerDT <- powerDT[, obsHalfHour := hms::as.hms(r_dateTime_nz)]
#powerDT[, obsHalfHour := format(ymd_hms(r_dateTimeHalfHour), "%H:%M:%S")]
powerDT <- powerDT[, month := lubridate::month(r_dateTime_nz)]
powerDT <- powerDT[, peak := 0]

powerDT <- powerDT[month == 12 | month == 1 | month == 2, season := "Summer"]
powerDT <- powerDT[month == 3 | month == 4 | month == 5, season := "Autumn"]
powerDT <- powerDT[month == 6 | month == 7 | month == 8, season := "Winter"]
powerDT <- powerDT[month == 9 | month == 10 | month == 11, season := "Spring"]

#Setting times of peak demand 
OP1S <- hms::as.hms("00:00:00")
OP1E <- hms::as.hms("16:30:00")

PS <- hms::as.hms("17:00:00")
PE <- hms::as.hms("21:00:00")

OP2S <- hms::as.hms("21:30:00")
OP2E <- hms::as.hms("23:30:00")

powerDT <- powerDT[, peak := ifelse(obsHalfHour >= OP1S & obsHalfHour <= OP1E,
                                    "Off Peak 1",
                                    NA)]
powerDT <- powerDT[, peak := ifelse(obsHalfHour >= OP2S & obsHalfHour <= OP2E,
                                    "Off Peak 2",
                                    peak)]
powerDT <- powerDT[, peak := ifelse(obsHalfHour >= PS & obsHalfHour <= PE,
                                    "Peak",
                                    peak)]
# this stops the RHS coercion errors

#----------------------------
#Actual calculations start
#----------------------------

```

```{r Part B: calculations for peak contribution}
powerDT[, year := lubridate::year(r_dateTime_nz)]

selectDT <- powerDT[circuit == 'imputedTotalDemand_circuitsToSum_v1.1' & 
                   obsHalfHour >= hms::as.hms("17:00:00") & obsHalfHour <= hms::as.hms("21:00:00"), .SD[which.max(meanPowerW)], # finds only the rows which are the max of the mean total load (XX should we be using the maxPowerW?? XX)
                   by = .(linkID, season, year)] # max vlaue within household, season, year

# This is the time of maximum peak demand for each household

kableExtra::kable(head(selectDT), caption = "Extracted peak load half-hours - first 6 rows")  %>% # test result
  kable_styling()

dataBucketDT <- data.table::data.table()
for(n in 1:nrow(selectDT)){
  # extract the rows which match the dateTime
  row <- selectDT[n]
  dt <- powerDT[linkID == row$linkID & # matches household
                  r_dateTime_nz == row$r_dateTime_nz, # matches dateTime
                .(linkID, year, season, r_dateTime_nz, circuit, nObs, meanPowerW, minPowerW, maxPowerW)] # selects just the basic columns we need
  dataBucketDT <- rbind(dataBucketDT, dt)
}

kableExtra::kable(head(dataBucketDT), caption = "Extracted peak load half-hour circuits - first 6 rows")  %>% # test result
  kable_styling()

# extract _just_ the circuits which are (or contain):
# - total load
# - heat pumps
# - hot water
# - oven
# - lighting

# dataBucketDT$eecaCircuit <- NULL

# split the circuit label to leave just the string and rthe id (we need the string)
dataBucketDT <- dataBucketDT[, c("circuitLabel","circuitID") := tstrsplit(circuit,"$", fixed = TRUE)]

# these match exactly to circuit label strings by matching to the string that came before the $ 
dataBucketDT <- dataBucketDT[, eecaCircuit := ifelse(circuitLabel == "Heat Pump" |
                                                       circuitLabel == "Theatre Heat Pump" |
                                                       circuitLabel == "Upstairs Heat Pumps" |
                                                       circuitLabel == "Heating",
                                                    "Heat Pump or Heating", 
                                                    "XX_Other") # default
                             ]

# these match if the string is in the circuit label (i.e. circuit label could contain other words)
# Be careful with these
dataBucketDT <- dataBucketDT[, eecaCircuit := ifelse( circuitLabel == "Oven" |
                                                        circuitLabel == "Range" |
                                                        circuitLabel == "Wall Oven" |
                                                        circuitLabel %like% "Oven &" |
                                                        circuitLabel %like% "Oven,", # if the circuit = Oven only
                                                    "Oven", eecaCircuit)]
dataBucketDT <- dataBucketDT[, eecaCircuit := ifelse(circuitLabel %like% "Hot water", 
                                                    "Hot water", eecaCircuit)]
dataBucketDT <- dataBucketDT[, eecaCircuit := ifelse(circuitLabel %like% "Hot Water", 
                                                    "Hot water", eecaCircuit)]
dataBucketDT <- dataBucketDT[, eecaCircuit := ifelse(circuitLabel %like% "Lighting" |
                                                       circuitLabel %like% "Lights", 
                                                    "Lighting", eecaCircuit)]
dataBucketDT <- dataBucketDT[, eecaCircuit := ifelse(circuitLabel %like% "imputedTotalDemand_circuitsToSum_v1.1", 
                                                    "Total", eecaCircuit)]
# test
t <- table(dataBucketDT$circuitLabel, dataBucketDT$eecaCircuit)

kableExtra::kable(t, caption = "Categoriesed circuits - XX check carefully! XX")  %>% # test result
  kable_styling()

t <- dcast(dataBucketDT[season == "Winter"], 
           linkID + year + season + r_dateTime_nz ~ eecaCircuit, 
           fun = mean, # won't do anything as we should just have 1 value?
           value.var = "meanPowerW") # take 1 household and turn data round

kableExtra::kable(t, caption = "Extracted winter peak load half-hour circuits (NaN indicates no such circuit and note that the mains/incomer is included in XX_Other so don't expect all the columns to sum to Total)")  %>% # test result
  kable_styling()

# Now just calculate the % using the identified circuits?


ResDT <- dcast(dataBucketDT, 
           linkID + year + season + r_dateTime_nz ~ eecaCircuit, 
           fun = mean, # won't do anything as we should just have 1 value?
           value.var = "meanPowerW") # take 1 household and turn data round

ResDT <- ResDT[, contribution_HW := `Hot water`/Total]
ResDT <- ResDT[, contribution_HP := `Heat Pump or Heating`/Total]
ResDT <- ResDT[, contribution_LI := `Lighting`/Total]
ResDT <- ResDT[, contribution_OV := `Oven`/Total]
ResDT <- ResDT[, contribution_XX := 1-((`Hot water` + `Heat Pump or Heating` + `Lighting` + `Oven`)/Total)]

#ResDT <- ResDT[, test := `contribution_HW` +
                       #  `contribution_HP`+
                       # `contribution_LI`+
                      #  `contribution_OV`+
                      #   `contribution_XX`]

##Visualisation---------------------------------


myPlot <- ggplot2::ggplot(subset(dataBucketDT, circuit %in% c("imputedTotalDemand_circuitsToSum_v1.1") & season %in% c("Winter") & year %in% c("2015")), aes(x=meanPowerW)) +
  geom_histogram() +
  scale_x_continuous( limits = c(0,13000))+
     geom_vline(aes(xintercept=mean(meanPowerW)),
            color="blue", linetype="dashed", size=0.5)+
  theme(text = element_text(family = "Cambria")) +
  ggtitle("Test") 
 # facet_grid(DOW ~ .) +
myPlot


myPlot <- ggplot2::ggplot(subset(dataBucketDT, eecaCircuit %in% c("Heat Pump or Heating") & season %in% c("Winter") & year %in% c("2015")), aes(x=lubridate::date(r_dateTime_nz))) +
  geom_boxplot(aes(y=maxPowerW, colour = maxPowerW), size=0.5, outlier.alpha = 0.1) +
  #scale_x_continuous( limits = c(0,13000))+
  theme(text = element_text(family = "Cambria")) +
  ggtitle("Test") 
 # facet_grid(DOW ~ .) +
myPlot
















ResDT <- gather(ResDT, eecaCircuit, maxPowerW, `Heat Pump or Heating`:`XX_Other`, factor_key = TRUE)



myPlot <- ggplot2::ggplot(subset(dataBucketDT, eecaCircuit =="Hot water"& year=="2015"), aes(x=meanPowerW, colour = season)) +
  geom_density() +
  #scale_x_continuous( limits = c(0,2000000))+
     #geom_vline(aes(xintercept=mean(totalEnergyWh)),
           # color="blue", linetype="dashed", size=0.5)+
  theme(text = element_text(family = "Cambria")) +
  ggtitle("Test") 
myPlot




ResDT <- as.data.table(ResDT)

ResDT <- ResDT[, HP := NA]
ResDT <- ResDT[, `HP` := ifelse(`eecaCircuit`== "Heat Pump or Heating", maxPowerW, NA)]



myPlot <- ggplot2::ggplot(subset(ResDT, year %in% c("2015") & season %in% c("Winter")),  fill = linkID) +
  geom_bar(aes(y= eecaCircuit, x = HP), stat = "identity", position = "dodge") +
  #geom_line(aes(y= V1)) +
  theme(text = element_text(family = "Cambria"))+
  #facet_grid(season ~ .) +
  ggtitle("XX") 
  #labs(x='Period', y='Cost in million NZD') 
myPlot














```
```{r Part B: calculations for annual kWh consumption}


energyDT <- copy(powerDT)

#energyDT <- energyDT[, meanEnergyWh := meanPowerW/2]#Converting W into Wh energy 



# split the circuit label to leave just the string and rthe id (we need the string)
energyDT <- energyDT[, c("circuitLabel","circuitID") := tstrsplit(circuit,"$", fixed = TRUE)]

# these match exactly to circuit label strings by matching to the string that came before the $ 
energyDT <- energyDT[, eecaCircuit := ifelse(circuitLabel == "Heat Pump" |
                                                       circuitLabel == "Theatre Heat Pump" |
                                                       circuitLabel == "Upstairs Heat Pumps" |
                                                       circuitLabel == "Heating",
                                                    "Heat Pump or Heating", 
                                                    "XX_Other") # default
                             ]

# these match if the string is in the circuit label (i.e. circuit label could contain other words)
# Be careful with these
energyDT <- energyDT[, eecaCircuit := ifelse( circuitLabel == "Oven" |
                                                        circuitLabel == "Range" |
                                                        circuitLabel == "Wall Oven" |
                                                        circuitLabel %like% "Oven &" |
                                                        circuitLabel %like% "Oven,", # if the circuit = Oven only
                                                    "Oven", eecaCircuit)]
energyDT <- energyDT[, eecaCircuit := ifelse(circuitLabel %like% "Hot water", 
                                                    "Hot water", eecaCircuit)]
energyDT <- energyDT[, eecaCircuit := ifelse(circuitLabel %like% "Hot Water", 
                                                    "Hot water", eecaCircuit)]
energyDT <- energyDT[, eecaCircuit := ifelse(circuitLabel %like% "Lighting" |
                                                       circuitLabel %like% "Lights", 
                                                    "Lighting", eecaCircuit)]
energyDT <- energyDT[, eecaCircuit := ifelse(circuitLabel %like% "imputedTotalDemand_circuitsToSum_v1.1", 
                                                    "Total", eecaCircuit)]
# test
t <- table(dataBucketDT$circuitLabel, dataBucketDT$eecaCircuit)

kableExtra::kable(t, caption = "Categoriesed circuits - XX check carefully! XX")  %>% # test result
  kable_styling()

#Conversion to energy Wh
energyDT <- energyDT[, meanEnergyWh := meanPowerW/2]
analysisDT <- copy(energyDT)
analysisDT <- analysisDT[, totalEnergyWh := sum(meanEnergyWh, na.rm = TRUE), keyby = .(linkID, season, eecaCircuit, year)]#Ignores NAs
analysisShortDT <- analysisDT[, .(totalEnergyWh = totalEnergyWh), keyby = .(linkID, season, eecaCircuit, year)]#For some reson by does not remove duplicates without crashing....
analysisShortDT <- unique(analysisShortDT)#Removing duplicates

#Calculating the contribution to annual energy consumption and turning off e-notation

options(scipen = 999)

analysisShortDT <- dcast(analysisShortDT, 
           linkID + year + season ~ eecaCircuit, 
           fun = mean, # won't do anything as we should just have 1 value?
           value.var = "totalEnergyWh") # take 1 household and turn data round

analysisShortDT <- analysisShortDT[, contribution_HW := `Hot water`/Total]
analysisShortDT <- analysisShortDT[, contribution_HP := `Heat Pump or Heating`/Total]
analysisShortDT <- analysisShortDT[, contribution_LI := `Lighting`/Total]
analysisShortDT <- analysisShortDT[, contribution_OV := `Oven`/Total]
analysisShortDT <- analysisShortDT[, contribution_XX := 1-((`Hot water` + `Heat Pump or Heating` + `Lighting` + `Oven`)/Total)]
# Tere are a lot of NA/Nan in the data. XXSensible to turn NaN into NA to receive more results??XX


#Summarising the variation in demand
#We need to dcast it back into the original form
analysisShortDT <- gather(analysisShortDT, eecaCircuit, totalEnergyWh, `Heat Pump or Heating`:`XX_Other`, factor_key = TRUE)


myPlot <- ggplot2::ggplot(subset(analysisShortDT, eecaCircuit =="Hot water"), aes(x=totalEnergyWh, colour=season)) +
  geom_density() +
  scale_x_continuous( limits = c(0,2000000))+
     geom_vline(aes(xintercept=mean(totalEnergyWh)),
            color="blue", linetype="dashed", size=0.5)+
  #facet_grid( season ~ year)+
  theme(text = element_text(family = "Cambria")) +
  ggtitle("Test") 
myPlot

```
```{r coincident sample peak: Part B}

sampleDT <- copy(powerDT)

# split the circuit label to leave just the string and rthe id (we need the string)
sampleDT <- sampleDT[, c("circuitLabel","circuitID") := tstrsplit(circuit,"$", fixed = TRUE)]

# these match exactly to circuit label strings by matching to the string that came before the $ 
sampleDT <- sampleDT[, eecaCircuit := ifelse(circuitLabel == "Heat Pump" |
                                                       circuitLabel == "Theatre Heat Pump" |
                                                       circuitLabel == "Upstairs Heat Pumps" |
                                                       circuitLabel == "Heating",
                                                    "Heat Pump or Heating", 
                                                    "XX_Other") # default
                             ]

# these match if the string is in the circuit label (i.e. circuit label could contain other words)
# Be careful with these
sampleDT <- sampleDT[, eecaCircuit := ifelse( circuitLabel == "Oven" |
                                                        circuitLabel == "Range" |
                                                        circuitLabel == "Wall Oven" |
                                                        circuitLabel %like% "Oven &" |
                                                        circuitLabel %like% "Oven,", # if the circuit = Oven only
                                                    "Oven", eecaCircuit)]
sampleDT <- sampleDT[, eecaCircuit := ifelse(circuitLabel %like% "Hot water", 
                                                    "Hot water", eecaCircuit)]
sampleDT <- sampleDT[, eecaCircuit := ifelse(circuitLabel %like% "Hot Water", 
                                                    "Hot water", eecaCircuit)]
sampleDT <- sampleDT[, eecaCircuit := ifelse(circuitLabel %like% "Lighting" |
                                                       circuitLabel %like% "Lights", 
                                                    "Lighting", eecaCircuit)]
sampleDT <- sampleDT[, eecaCircuit := ifelse(circuitLabel %like% "imputedTotalDemand_circuitsToSum_v1.1", 
                                                    "Total", eecaCircuit)]

sampleDT <- sampleDT[, summeanPowerW := NA]

sampleShortDT <- sampleDT[, .(summeanPowerW = sum(meanPowerW, na.rm = TRUE), 
                              nobs=.N), keyby=.(eecaCircuit, date, season, year, obsHalfHour)]#This is the aggregated Wattage for each circuit month etc. see keyby in order to conduct sample coincident peak analysis 


sampleShortDT <- sampleShortDT[, averagePowerW := summeanPowerW/nobs]#We have to consider that some of the obs have only one obs, some have up to 200. We need to take the average to identify the top 20 entries (their time of occurance)


sample2015DT <- sampleShortDT[ !(year %in% c(2014, 2016, 2017, 2018))]#Getting rid of years that are not necessary for this analysis

sort(sample2015DT$averagePowerW, decreasing = TRUE)#Now identufy these top20 times in the original data table and conduct analysis again

####Filtering the top20 peak half-hours based on our sample. XXThis is hard-coded - is there a better way to do it??XX

filteredDT <- copy(powerDT)
filteredDT = filteredDT %>% filter(date == "2015-06-28" & obsHalfHour == hms::as.hms("18:00:00") |
                                   date == "2015-08-21" & obsHalfHour == hms::as.hms("07:00:00") |
                                   date == "2015-06-23" & obsHalfHour == hms::as.hms("18:00:00") |
                                   date == "2015-06-24" & obsHalfHour == hms::as.hms("07:00:00") |
                                   date == "2015-05-29" & obsHalfHour == hms::as.hms("07:00:00") |
                                   date == "2015-06-17" & obsHalfHour == hms::as.hms("07:00:00") |
                                   date == "2015-08-12" & obsHalfHour == hms::as.hms("07:00:00") |
                                   date == "2015-06-23" & obsHalfHour == hms::as.hms("17:30:00") |
                                   date == "2015-06-26" & obsHalfHour == hms::as.hms("07:00:00") |
                                   date == "2015-06-25" & obsHalfHour == hms::as.hms("07:30:00") |
                                   date == "2015-06-23" & obsHalfHour == hms::as.hms("18:30:00") |
                                   date == "2015-05-25" & obsHalfHour == hms::as.hms("19:00:00") |
                                   date == "2015-06-23" & obsHalfHour == hms::as.hms("07:00:00") |
                                   date == "2015-08-10" & obsHalfHour == hms::as.hms("20:00:00") |
                                   date == "2015-06-26" & obsHalfHour == hms::as.hms("07:30:00") |
                                   date == "2015-07-10" & obsHalfHour == hms::as.hms("07:30:00") |
                                   date == "2015-08-28" & obsHalfHour == hms::as.hms("07:00:00") |
                                   date == "2015-07-09" & obsHalfHour == hms::as.hms("07:30:00") |
                                   date == "2015-06-23" & obsHalfHour == hms::as.hms("19:30:00") |
                                   date == "2015-05-27" & obsHalfHour == hms::as.hms("07:00:00"))





```
# Peak Contribution

```{r peakContrib}
# use origPowerDT 
```

# Annual Contribution

# Conservation Load Factor

# Summary

# Data Annex

Descriptive statistics for aggregate half hourly power data for all households and all circuits:

```{r skimData}
skimr::skim(origPowerDT)
```

The following tables show descriptive statistics for the meanPowerW values for each circuit by household.

```{r powerCube, results = "asis"}
ids <- unique(origPowerDT$linkID)

for(hh in ids){
  # prints a lot of tables
    t <- data.table::cube(origPowerDT[linkID == hh], j = c(list(meanPowerW = mean(meanPowerW),
                                                              minPowerW = min(meanPowerW),
                                                              maxPowerW = max(meanPowerW),
                                                              nObs = .N)), by = c("circuit"))
    # NA in circuit column of ersults table = All
    t[, circuit := ifelse(is.na(circuit), "All", circuit)]
    print(kableExtra::kable(t, caption = paste0(hh, ": Mean of half-hourly mean power (W) by circuit type")))
}

```

# Runtime


```{r check runtime, include=FALSE}
t <- proc.time() - startTime
elapsed <- t[[3]]
```

Analysis completed in `r round(elapsed,2)` seconds ( `r round(elapsed/60,2)` minutes) using [knitr](https://cran.r-project.org/package=knitr) in [RStudio](http://www.rstudio.com) with `r R.version.string` running on `r R.version$platform`.

# R environment

## R packages used

 * base R [@baseR]
 * bookdown [@bookdown]
 * data.table [@data.table]
 * ggplot2 [@ggplot2]
 * kableExtra [@kableExtra]
 * knitr [@knitr]
 * lubridate [@lubridate]
 * rmarkdown [@rmarkdown]

## Session info

```{r sessionInfo, echo=FALSE}
sessionInfo()
```

# References
