---
params:
  subtitle: ""
  title: ""
  authors: ""
title: '`r params$title`'
subtitle: '`r params$subtitle`'
author: '`r params$authors`'
date: 'Last run at: `r getRunDateTime()`'
output:
  bookdown::html_document2:
    fig_caption: yes
    code_folding: hide
    number_sections: yes
    toc: yes
    toc_depth: 2
    toc_float: TRUE
  bookdown::pdf_document2:
    fig_caption: yes
    number_sections: yes
bibliography: '`r paste0(here::here(), "/bibliography.bib")`'
---

```{r knitrSetup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE) # by default turn off code echo
```


```{r codeSetup, include=FALSE}
# Set start time ----
startTime <- proc.time()

# Local parameters ----
b2Kb <- 1024 #http://whatsabyte.com/P1/byteconverter.htm
b2Mb <- 1048576
plotLoc <- paste0(repoParams$repoLoc, "/docs/plots/") # where to put the plots (if any)

# Packages used in the report ----
rmdLibs <- c("ggplot2", # plots
          "kableExtra", # fancy tables
          "hms", # times
          "skimr", # for skim
          "tidyr" # for gather
          )
GREENGridEECA::loadLibraries(rmdLibs)

# Local functions ----



```

\newpage

# About

## Citation

```{r citation, child=repoParams$citation}
```

## Report circulation:

 * Public – this report is intended for publication following EECA approval.
 
## License

```{r ccby license, child=repoParams$licenseCCBY}
```
 
## History

```{r history, child=repoParams$history}
```
 * this [report's edit history](https://github.com/CfSOtago/GREENGridEECA/commits/master/reports/partB_dataAnalysis)
 
## Support

```{r generic support, child=repoParams$support}
```
 
\newpage

# Introduction

This report uses the GREEN Grid project [@stephenson_smart_2017] research data to analyse a variety of residential household appliances and their contribution to peak demand under several scenarios.

# Data

```{r generic sample, child=repoParams$data}
```

```{r partBdataProcessing}
# put all this here before you report on it
# this code _could_ go in the makeFile if you want...

#New DT
powerDT <- copy(origPowerDT) # need to copy as data.table works by reference https://www.rdocumentation.org/packages/data.table/versions/1.12.2/topics/copy

#DT modifications

#Excluding households based on Part A report: https://cfsotago.github.io/GREENGridEECA/#part-a--data-processing
exclude <- c("rf_14", "rf_25", "rf_26", "rf_43", "rf_46")
powerDT <- powerDT[!(linkID %in% exclude)]

# setting negative values to NA
powerDT <- powerDT[, meanPowerW := ifelse(meanPowerW <0, NA, meanPowerW)]
powerDT <- powerDT[, sdPowerW := ifelse(sdPowerW <0, NA, sdPowerW)]
powerDT <- powerDT[, minPowerW := ifelse(minPowerW <0, NA, minPowerW)]
powerDT <- powerDT[, maxPowerW := ifelse(maxPowerW <0, NA, maxPowerW)]


# set to NZ time from UTC
powerDT <- powerDT[, r_dateTime_nz := lubridate::as_datetime(r_dateTimeHalfHour, 
                                               tz = "Pacific/Auckland")] # this will be UTC unless you set this

#Define Winter/else
powerDT <- powerDT[, date := lubridate::date(r_dateTime_nz)]
powerDT <- powerDT[, obsHalfHour := hms::as.hms(r_dateTime_nz)]
#powerDT[, obsHalfHour := format(ymd_hms(r_dateTimeHalfHour), "%H:%M:%S")]
powerDT <- powerDT[, month := lubridate::month(r_dateTime_nz)]
powerDT <- powerDT[, peak := 0]

powerDT <- powerDT[month == 12 | month == 1 | month == 2, season := "Summer"]
powerDT <- powerDT[month == 3 | month == 4 | month == 5, season := "Autumn"]
powerDT <- powerDT[month == 6 | month == 7 | month == 8, season := "Winter"]
powerDT <- powerDT[month == 9 | month == 10 | month == 11, season := "Spring"]

#Setting times of peak demand 
OP1S <- hms::as.hms("00:00:00")
OP1E <- hms::as.hms("16:30:00")

PS <- hms::as.hms("17:00:00")
PE <- hms::as.hms("21:00:00")

OP2S <- hms::as.hms("21:30:00")
OP2E <- hms::as.hms("23:30:00")

powerDT <- powerDT[, peak := ifelse(obsHalfHour >= OP1S & obsHalfHour <= OP1E,
                                    "Off Peak 1",
                                    NA)]
powerDT <- powerDT[, peak := ifelse(obsHalfHour >= OP2S & obsHalfHour <= OP2E,
                                    "Off Peak 2",
                                    peak)]
powerDT <- powerDT[, peak := ifelse(obsHalfHour >= PS & obsHalfHour <= PE,
                                    "Peak",
                                    peak)]
# this stops the RHS coercion errors
```



# Peak Contribution

For each dwelling:

 * calculate mean total total load
 * find the maximum total load (kW) half hour
 * calculate mean percentage contribution of each separately identifiable load type (lighting, hot water, heat pump, oven) in the maximum total load half-hour
 
 ...at ‘peak’ as defined by:
 
 * Winter evenings 17:00 - 21:00 
 * Regional/network peak
 * Sample co-incident peak - - select the 'peak' half-hour across all dwellings

To do this we classify the circuit labels according to the load types mentioned above (see Table \@ref(tab:categoriseCircuitsTable) in the Data Annex).

## Winter (June - August)  evenings 17:00 – 21:00

In this section we select the peak-period half hours for all households for the winter period and then locate the half-hour which had the maximum total load for that dwelling. Table \@ref(tab:findMaxHalfHours) shows an example data extract.

```{r findMaxHalfHours}
powerDT[, year := lubridate::year(r_dateTime_nz)] # so we can do per-year analysis

selectDT <- powerDT[circuit == 'imputedTotalDemand_circuitsToSum_v1.1' & 
                   obsHalfHour >= hms::as.hms("17:00:00") & 
                     obsHalfHour <= hms::as.hms("21:00:00"), .SD[which.max(meanPowerW)], # finds only the rows which are the max of the mean total load (XX should we be using the maxPowerW?? XX)
                   by = .(linkID, season, year)] # max value within household, season, year

# This is the time of maximum peak demand for each household

#kableExtra::kable(head(selectDT), caption = "Extracted peak load half-hours - first 6 rows")  %>% # test result
#  kable_styling()

dataBucketDT <- data.table::data.table()
for(n in 1:nrow(selectDT)){
  # extract the rows which match the dateTime
  row <- selectDT[n]
  dt <- powerDT[linkID == row$linkID & # matches household
                  r_dateTime_nz == row$r_dateTime_nz, # matches dateTime
                .(linkID, year, season, r_dateTime_nz, circuit, nObs, meanPowerW, minPowerW, maxPowerW)] # selects just the basic columns we need
  dataBucketDT <- rbind(dataBucketDT, dt)
}



# extract _just_ the circuits which are (or contain):
# - total load
# - heat pumps
# - hot water
# - oven
# - lighting

dataBucketDT <- GREENGridEECA::labelEECACircuits(dataBucketDT) # use the function to split the circuit string for easier string matching

kableExtra::kable(head(dataBucketDT, 10), caption = "Extracted peak load half-hour circuits - first 10 rows showing circuit demand at the peak total demand half-hour")  %>% # test result
  kable_styling()

# Full EECA category label check table is in Data Annex
categoriseCircuitsTable <- table(dataBucketDT$circuitLabel, dataBucketDT$eecaCircuit)

```

Table \@ref(tab:winterPeaktestTable) shows the winter peak load half-hours for each dwelling and year in winter. In this data extract, NaN indicates that no circuit data was obtained for this dwelling in this specific time period. We furthermore identify the contribution of each circuit label to the total demand. 

```{r winterPeaktestTable}
resAllSeasonsDT <- dcast(dataBucketDT,
           linkID + year + season + r_dateTime_nz ~ eecaCircuit, 
           fun = mean, # won't do anything as we should just have 1 value?
           value.var = "meanPowerW") # take 1 household and turn data round

# Now just calculate the % using the identified circuits?


resAllSeasonsDT <- resAllSeasonsDT[, contribution_HW := `Hot water`/Total]
resAllSeasonsDT <- resAllSeasonsDT[, contribution_HP := `Heat Pump or Heating`/Total]
resAllSeasonsDT <- resAllSeasonsDT[, contribution_LI := `Lighting`/Total]
resAllSeasonsDT <- resAllSeasonsDT[, contribution_OV := `Oven`/Total]
resAllSeasonsDT <- resAllSeasonsDT[, contribution_XX := 1-((`Hot water` + `Heat Pump or Heating` + `Lighting` + `Oven`)/Total)]

kableExtra::kable(head(resAllSeasonsDT[season == "Winter"], 10), digits = 3,
                  caption = "Example data: Extracted winter peak load half-hour circuits (NaN indicates no such circuit)")  %>% # test result
  kable_styling()

```

```{r reducedSizeCodeforP1}

summaryP1DT <- copy(resAllSeasonsDT) #This is the summary table to present to EECA for the first definition of peak demand

summaryP1DT<-summaryP1DT[, c("Heat Pump or Heating", "Hot water", "Lighting", "Oven", "Total", "XX_Other") := NULL]

#summaryP1DT<-summaryP1DT[, averageContriHW := ]
summaryP1DT <- setnames(summaryP1DT, old=c("contribution_HW","contribution_HP", "contribution_LI", "contribution_OV", "contribution_XX"),
                        new=c("Hot Water", "Heat Pump", "Lighting", "Oven", "Others"))

#summaryP1DT <- data.table::as.data.table(gather(summaryP1DT, eecaCircuit, meanPowerW, `Heat Pump or Heating`:`XX_Other`, factor_key = TRUE))
summaryP1DT <- data.table::as.data.table(gather(summaryP1DT, eecaLabelContri, contribution, `Hot Water`:`Others`, factor_key = TRUE))#This brings our data into a nice form for the plot

summaryP1DT <- summaryP1DT[, .(averageContri = mean(contribution, na.rm = TRUE), 
                              nobs=.N, sd=sd(contribution, na.rm = TRUE)), keyby=.(eecaLabelContri, season, year)]

summaryP1DT <- summaryP1DT[, averageContri := averageContri*100 ]#Conversion to % for plot

summaryP1DT$season <- factor(summaryP1DT$season, levels = c("Spring","Summer",
                                                    "Autumn", "Winter"))#This puts the seasons in the right order in the plot

```

```{r winter2015contributionPlot}

myPlot <- ggplot2::ggplot(summaryP1DT[season == "Winter" & year == 2015], aes(x= eecaLabelContri, fill = eecaLabelContri)) +
  geom_bar(aes(y = averageContri), stat = "identity")+
  theme(text = element_text(family = "Cambria"), legend.position = "none",
        axis.text.x = element_text(colour = "black"),
        axis.text.y = element_text(colour = "black")) +
  
  #facet_grid(season ~ .) +
  scale_y_continuous(breaks = c(5, 10, 15, 20, 25, 30, 35)) +
  ggtitle("Contribution to peak demand (17:00-21:00) for winter in 2015") +
  labs(x='Circuit', y='Contribution in %') 



#XX_Into Annex??_XX


```
Figure \@ref(fig:2015contributionPlot) shows the percentual contribution to peak demand for 2015 for each season and circuit. Please note, that the stacked bar chart does not add up to 100% as we averaged the circuit contributions over all households. It is worth mentioning that Figure \@ref(fig:2015contributionPlot) shows a percentual contribution to peak demand and does not depict power contributions. The contribution of hot water slightly increases in summer whereas contribution of heat pumps decreases over summer. Hot water is identified as the appliance that is relatively contributing the most to peak demand in 2015.

```{r 2015contributionPlot, fig.cap="Percentual contribution to peak demand (17:00-21:00) in 2015"}


#The stacks do not add up to 100 as we have averaged the contributions over all households. XXMention in the textXX

myPlot <- ggplot2::ggplot(summaryP1DT[year == 2015], aes(x= season, fill = eecaLabelContri)) +
  geom_bar(aes(y = averageContri), stat = "identity")+
  theme(text = element_text(family = "Cambria"),
        axis.text.y = element_blank(),
        axis.text.x = element_text(colour = "black"),
        axis.ticks.y = element_blank())+
  
    geom_text(aes(y = averageContri,
              label = sprintf("%0.2f",averageContri)),
           position = position_stack(vjust = .5))+
  
  #facet_grid(season ~ .) +
  #scale_y_continuous(breaks = c()) +
  #ggtitle("Contribution to peak demand (17:00-21:00) in 2015") +
  guides(fill=guide_legend(title="Circuit"))+
  labs(x='Season', y='Contribution in %') 
myPlot
#Now do the same for wattage contribution...


```
```{r wattageContributionPeak1}

#This section aims to calculate the wattage contribution. We recycle previous results...

ContriW1DT <- dcast(dataBucketDT,#This tis the contribution DT for wattage and the first definition of peak demand
           linkID + year + season + r_dateTime_nz ~ eecaCircuit, 
           fun = mean, # won't do anything as we should just have 1 value?
           value.var = "meanPowerW")
ContriW1DT<-ContriW1DT[, c( "Total") := NULL]#We do not need this column

ContriW1DT <- setnames(ContriW1DT, old=c("Heat Pump or Heating","Hot water", "Lighting", "Oven", "XX_Other"),
                        new=c("Heat Pump", "Hot Water", "Lighting", "Oven", "Others"))
ContriW1DT <- data.table::as.data.table(gather(ContriW1DT, eecaLabelContri, contribution, `Heat Pump`:`Others`, factor_key = TRUE))#This brings our data into a nice form for the plot

ContriW1DT <- ContriW1DT[, .(averageContri = mean(contribution, na.rm = TRUE), 
                              nobs=.N, sd=sd(contribution, na.rm = TRUE)), keyby=.(eecaLabelContri, season, year)]

ContriW1DT$season <- factor(ContriW1DT$season, levels = c("Spring","Summer",
                                                    "Autumn", "Winter"))#This puts the seasons in the right order in the plot
ContriW1DT$eecaLabelContri <- factor(ContriW1DT$eecaLabelContri, levels = c("Hot Water","Heat Pump",
                                                    "Lighting", "Oven", "Others"))#This puts the seasons in the right order in the plot
```

In addition, Figure \@ref(fig:wattageContributionPeak1Plot) verfies what Figure \@ref(fig:2015contributionPlot) already indicated. Hot water, on average, contributes the most peak demand.



```{r wattageContributionPeak1Plot, fig.cap="Wattage contribution to peak demand (17:00-21:00) in 2015 "}

myPlot <- ggplot2::ggplot(ContriW1DT[year == 2015], aes(x= season, fill = eecaLabelContri)) +
  geom_bar(aes(y = averageContri), stat = "identity")+
  theme(text = element_text(family = "Cambria"),
        axis.text.y = element_blank(),
        axis.text.x = element_text(colour = "black"),
        axis.ticks.y = element_blank())+
  
    geom_text(aes(y = averageContri,
              label = sprintf("%0.2f",averageContri)),
           position = position_stack(vjust = .5))+
  
  #facet_grid(season ~ .) +
  #scale_y_continuous(breaks = c()) +
  #ggtitle("Contribution to peak demand (17:00-21:00) in 2015") +
  guides(fill=guide_legend(title="Circuit"))+
  labs(x='Season', y='Power in W') 
myPlot


```

## Region/network coincident peak

To be done 

## Sample coincident peak

The sample coincie´dent peak utilises the GREENGrid sample to define peak demand. 
                
```{r sampleCoincidentPeak}

sampleDT <- labelEECACircuits(powerDT)

sampleDT <- sampleDT[, summeanPowerW := NA]

sampleShortDT <- sampleDT[, .(summeanPowerW = sum(meanPowerW, na.rm = TRUE), 
                              nobs=.N), keyby=.(eecaCircuit, date, season, year, obsHalfHour)]#This is the aggregated Wattage for each circuit month etc. see keyby in order to conduct sample coincident peak analysis 


sampleShortDT <- sampleShortDT[, averagePowerW := summeanPowerW/nobs]#We have to consider that some of the obs have only one obs, some have up to 200. We need to take the average to identify the top 20 entries (their time of occurance)


sample2015DT <- sampleShortDT[year == 2015] # Getting rid of years that are not necessary for this analysis

sample2015DT <- sort(sample2015DT$averagePowerW, decreasing = TRUE) #Now identufy these top20 times in the original data table and conduct analysis again. We only use this data table to identify the peak half hours. Now we go back to original data files

####Filtering the top20 peak half-hours based on our sample. XXThis is hard-coded - is there a better way to do it??XX

filteredDT <- powerDT %>% filter(date == "2015-06-28" & obsHalfHour == hms::as.hms("18:00:00") |
                                   date == "2015-08-21" & obsHalfHour == hms::as.hms("07:00:00") |
                                   date == "2015-06-23" & obsHalfHour == hms::as.hms("18:00:00") |
                                   date == "2015-06-24" & obsHalfHour == hms::as.hms("07:00:00") |
                                   date == "2015-05-29" & obsHalfHour == hms::as.hms("07:00:00") |
                                   date == "2015-06-17" & obsHalfHour == hms::as.hms("07:00:00") |
                                   date == "2015-08-12" & obsHalfHour == hms::as.hms("07:00:00") |
                                   date == "2015-06-23" & obsHalfHour == hms::as.hms("17:30:00") |
                                   date == "2015-06-26" & obsHalfHour == hms::as.hms("07:00:00") |
                                   date == "2015-06-25" & obsHalfHour == hms::as.hms("07:30:00") |
                                   date == "2015-06-23" & obsHalfHour == hms::as.hms("18:30:00") |
                                   date == "2015-05-25" & obsHalfHour == hms::as.hms("19:00:00") |
                                   date == "2015-06-23" & obsHalfHour == hms::as.hms("07:00:00") |
                                   date == "2015-08-10" & obsHalfHour == hms::as.hms("20:00:00") |
                                   date == "2015-06-26" & obsHalfHour == hms::as.hms("07:30:00") |
                                   date == "2015-07-10" & obsHalfHour == hms::as.hms("07:30:00") |
                                   date == "2015-08-28" & obsHalfHour == hms::as.hms("07:00:00") |
                                   date == "2015-07-09" & obsHalfHour == hms::as.hms("07:30:00") |
                                   date == "2015-06-23" & obsHalfHour == hms::as.hms("19:30:00") |
                                   date == "2015-05-27" & obsHalfHour == hms::as.hms("07:00:00"))


filteredDT <- as.data.table(filteredDT)
filteredDT <- labelEECACircuits(filteredDT)
```

```{r winterPeaktestTableSample}
contriSampleDT <- dcast(filteredDT,
           linkID + year + season + r_dateTime_nz ~ eecaCircuit, 
           fun = mean, # won't do anything as we should just have 1 value?
           value.var = "meanPowerW") # take 1 household and turn data round

# Now just calculate the % using the identified circuits?


contriSampleDT <- contriSampleDT[, contribution_HW := `Hot water`/Total]
contriSampleDT <- contriSampleDT[, contribution_HP := `Heat Pump or Heating`/Total]
contriSampleDT <- contriSampleDT[, contribution_LI := `Lighting`/Total]
contriSampleDT <- contriSampleDT[, contribution_OV := `Oven`/Total]
contriSampleDT <- contriSampleDT[, contribution_XX := 1-((`Hot water` + `Heat Pump or Heating` + `Lighting` + `Oven`)/Total)]

kableExtra::kable(head(resAllSeasonsDT[season == "Winter"], 10), digits = 3,
                  caption = "Example data: Extracted top 20 half-hours (NaN indicates no such circuit)")  %>% # test result
  #kable_styling()

```
```{r reducedSizeCodeforSample}

summaryPSDT <- copy(contriSampleDT) #This is the summary table to present to EECA for the first definition of peak demand

summaryPSDT<-summaryPSDT[, c("Heat Pump or Heating", "Hot water", "Lighting", "Oven", "Total", "XX_Other") := NULL]


summaryPSDT <- setnames(summaryPSDT, old=c("contribution_HW","contribution_HP", "contribution_LI", "contribution_OV", "contribution_XX"),
                        new=c("Hot Water", "Heat Pump", "Lighting", "Oven", "Others"))

summaryPSDT <- data.table::as.data.table(gather(summaryPSDT, eecaLabelContri, contribution, `Hot Water`:`Others`, factor_key = TRUE))#This brings our data into a nice form for the plot

summaryPSDT <- summaryPSDT[, .(averageContri = mean(contribution, na.rm = TRUE), 
                              nobs=.N, sd=sd(contribution, na.rm = TRUE)), keyby=.(eecaLabelContri, season, year, r_dateTime_nz)]

summaryPSDT <- summaryPSDT[, averageContri := averageContri*100 ]#Conversion to % for plot

summaryPSDT$season <- factor(summaryPSDT$season, levels = c("Spring","Summer",
                                                    "Autumn", "Winter"))#This puts the seasons in the right order in the plot
```

```{r 2015contributionPlotSample, fig.cap="Percentual contribution to peak demand on the 2015-06-28 at 18:00:00 (one of the top 20) "}


#The stacks do not add up to 100 as we have averaged the contributions over all households. XXMention in the textXX

myPlot <- ggplot2::ggplot(summaryPSDT[r_dateTime_nz =="2015-06-28 18:00:00"], aes(x= eecaLabelContri, fill = eecaLabelContri)) +
  geom_bar(aes(y = averageContri), stat = "identity")+
  theme(text = element_text(family = "Cambria"),
        axis.text.y = element_blank(),
        axis.text.x = element_text(colour = "black"),
        legend.position = "none",
        axis.ticks.y = element_blank())+
  
    geom_text(aes(y = averageContri,
             label = sprintf("%0.2f",averageContri)),
            position = position_stack(vjust = .5))+
  
  #facet_grid(season ~ .) +
  #scale_y_continuous(breaks = c()) +
  #ggtitle("Contribution to peak demand (17:00-21:00) in 2015") +
  guides(fill=guide_legend(title="Circuit"))+
  labs(x='Circuit', y='Contribution in %') 
myPlot
#Now do the same for wattage contribution...


```






# Annual Contribution

kWh not kW...

```{r partBannualConsumption}
# kWh

# new DT ( do we need to?)
energyDT <- copy(powerDT)

#energyDT <- energyDT[, meanEnergyWh := meanPowerW/2]#Converting W into Wh energy 



#Conversion to energy Wh
energyDT <- energyDT[, meanEnergyWh := meanPowerW/2]
analysisDT <- copy(energyDT) # another new DT. Do we need to?
analysisDT <- analysisDT[, totalEnergyWh := sum(meanEnergyWh, na.rm = TRUE), 
                         keyby = .(linkID, season, eecaCircuit, year)]#Ignores NAs
analysisShortDT <- analysisDT[, .(totalEnergyWh = totalEnergyWh), 
                              keyby = .(linkID, season, eecaCircuit, year)] #For some reason by does not remove duplicates without crashing....

analysisShortDT <- unique(analysisShortDT)# Removing duplicates

# Calculating the contribution to annual energy consumption and turning off e-notation

options(scipen = 999)

analysisShortDT <- dcast(analysisShortDT, 
           linkID + year + season ~ eecaCircuit, 
           fun = mean, # won't do anything as we should just have 1 value?
           value.var = "totalEnergyWh") # take 1 household and turn data round

analysisShortDT <- analysisShortDT[, contribution_HW := `Hot water`/Total]
analysisShortDT <- analysisShortDT[, contribution_HP := `Heat Pump or Heating`/Total]
analysisShortDT <- analysisShortDT[, contribution_LI := `Lighting`/Total]
analysisShortDT <- analysisShortDT[, contribution_OV := `Oven`/Total]
analysisShortDT <- analysisShortDT[, contribution_XX := 1-((`Hot water` + `Heat Pump or Heating` + `Lighting` + `Oven`)/Total)]
# Tere are a lot of NA/Nan in the data. XXSensible to turn NaN into NA to receive more results??XX


#Summarising the variation in demand
#We need to dcast it back into the original form
dt <- data.table::as.data.table(gather(analysisShortDT, eecaCircuit, totalEnergyWh, `Heat Pump or Heating`:`XX_Other`, factor_key = TRUE))
```

Figure \@ref(fig:annualConsplot1) shows...

```{r annualConsplot1, fig.cap="Total kWh for each dwelling (?) be season in 2015"}
myPlot <- ggplot2::ggplot(dt[eecaCircuit =="Hot water"], aes(x=totalEnergyWh/1000, colour=season)) +
  geom_density() +
  labs(x = "Total energy (kWh)") +
  #scale_x_continuous( limits = c(0,2000))+
     geom_vline(aes(xintercept=mean(totalEnergyWh/1000)),
            color="blue", linetype="dashed", size=0.5)+
  #facet_grid( season ~ year)+
  theme(text = element_text(family = "Cambria")) 
myPlot

```


# Conservation Load Factor

# Summary

# Data Annex

Figure \@ref(fig:winterPeakplot1) shows... for winter 2015 for the selected maximum load half-hours.

```{r winterPeakplot1, fig.cap="test mean total load"}
myPlot <- ggplot2::ggplot(resAllSeasonsDT[season == "Winter" & year == 2015], aes(x=Total)) +
  geom_histogram() +
  labs(x = "Mean total load per half hour") +
  scale_x_continuous( limits = c(0,13000))+
     geom_vline(aes(xintercept=mean(Total)),
            color="blue", linetype="dashed", size=0.5)+
  theme(text = element_text(family = "Cambria")) +
  ggtitle("Test") 
 # facet_grid(DOW ~ .) +
myPlot
```

Figure \@ref(fig:winterPeakplot2) shows...

```{r winterPeakplot2, fig.cap="Test max power for heating"}
myPlot <- ggplot2::ggplot(dataBucketDT[eecaCircuit  == "Heat Pump or Heating" & season == "Winter" & year == 2015],
                          aes(x=lubridate::date(r_dateTime_nz), group = lubridate::date(r_dateTime_nz))) +
  geom_boxplot(aes(y=maxPowerW, colour = maxPowerW), size=0.5, outlier.alpha = 0.1) +
  #scale_x_continuous( limits = c(0,13000))+
  # facet_grid(DOW ~ .) +
  theme(text = element_text(family = "Cambria")) 
 
myPlot

```

Figure \@ref(fig:winterPeakplot3) shows...

```{r winterPeakplot3, fig.cap="Test mean power for heating in peak half load hours"}
myPlot <- ggplot2::ggplot(resAllSeasonsDT[year==2015], aes(x=`Heat Pump or Heating`, colour = season)) +
  geom_density() +
  #scale_x_continuous( limits = c(0,2000000))+
     #geom_vline(aes(xintercept=mean(totalEnergyWh)),
           # color="blue", linetype="dashed", size=0.5)+
  theme(text = element_text(family = "Cambria")) +
  ggtitle("Test") 
myPlot


```

Figure \@ref(fig:winterPeakplot4) shows...

> XX what is the gather for?

```{r winterPeakplot4, fig.cap="What are we trying to do here?"}

# put things where they are used

# dplyr so need to re-create as d.t
resDT <- data.table::as.data.table(gather(resAllSeasonsDT, eecaCircuit, maxPowerW, `Heat Pump or Heating`:`XX_Other`, factor_key = TRUE))

resDT <- resDT[, HP := NA]
resDT <- resDT[, `HP` := ifelse(`eecaCircuit`== "Heat Pump or Heating", maxPowerW, NA)]

myPlot <- ggplot2::ggplot(subset(resDT, year %in% c("2015") & season %in% c("Winter")),  fill = linkID) +
  geom_bar(aes(y= eecaCircuit, x = HP), stat = "identity", position = "dodge") +
  #geom_line(aes(y= V1)) +
  theme(text = element_text(family = "Cambria"))+
  #facet_grid(season ~ .) +
  ggtitle("XX") 
  #labs(x='Period', y='Cost in million NZD') 
myPlot


```

## Categorised circuit labels

Table \@ref(tab:categoriseCircuitsTable) shows the categorised circuit labels used in the analysis.

```{r categoriseCircuitsTable}
kableExtra::kable(categoriseCircuitsTable, caption = "Categorised circuits - XX check carefully! Comment out when happy XX")  %>% # test result
  kable_styling()
```

## Original data description

Descriptive statistics for aggregate half hourly power data for all households and all circuits:

```{r skimData}
skimr::skim(origPowerDT)
```

The following tables show descriptive statistics for the meanPowerW values for each circuit by household.

```{r powerCube, results = "asis"}
ids <- unique(origPowerDT$linkID)

for(hh in ids){
  # prints a lot of tables
    t <- data.table::cube(origPowerDT[linkID == hh], j = c(list(meanPowerW = mean(meanPowerW),
                                                              minPowerW = min(meanPowerW),
                                                              maxPowerW = max(meanPowerW),
                                                              nObs = .N)), by = c("circuit"))
    # NA in circuit column of ersults table = All
    t[, circuit := ifelse(is.na(circuit), "All", circuit)]
    print(kableExtra::kable(t, caption = paste0(hh, ": Mean of half-hourly mean power (W) by circuit type")))
}

```

# Runtime


```{r check runtime, include=FALSE}
t <- proc.time() - startTime
elapsed <- t[[3]]
```

Analysis completed in `r round(elapsed,2)` seconds ( `r round(elapsed/60,2)` minutes) using [knitr](https://cran.r-project.org/package=knitr) in [RStudio](http://www.rstudio.com) with `r R.version.string` running on `r R.version$platform`.

# R environment

## R packages used

 * base R [@baseR]
 * bookdown [@bookdown]
 * data.table [@data.table]
 * ggplot2 [@ggplot2]
 * kableExtra [@kableExtra]
 * knitr [@knitr]
 * lubridate [@lubridate]
 * rmarkdown [@rmarkdown]

## Session info

```{r sessionInfo, echo=FALSE}
sessionInfo()
```

# References
